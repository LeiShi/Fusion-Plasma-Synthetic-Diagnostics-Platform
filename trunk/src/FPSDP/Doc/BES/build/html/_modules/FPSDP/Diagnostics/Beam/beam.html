<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>FPSDP.Diagnostics.Beam.beam &mdash; BES 0.8 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '0.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="BES 0.8 documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../FPSDP.html">BES 0.8 documentation</a> &raquo;</li>
          <li><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for FPSDP.Diagnostics.Beam.beam</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">FPSDP.Plasma.Collisions.collisions</span> <span class="kn">as</span> <span class="nn">col</span>
<span class="kn">import</span> <span class="nn">FPSDP.Maths.Integration</span> <span class="kn">as</span> <span class="nn">integ</span>
<span class="kn">import</span> <span class="nn">ConfigParser</span> <span class="kn">as</span> <span class="nn">psr</span>
<span class="kn">import</span> <span class="nn">FPSDP.Maths.Interpolation</span> <span class="kn">as</span> <span class="nn">Fint</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>

<div class="viewcode-block" id="Beam1D"><a class="viewcode-back" href="../../../../FPSDP.Diagnostics.Beam.html#FPSDP.Diagnostics.Beam.beam.Beam1D">[docs]</a><span class="k">class</span> <span class="nc">Beam1D</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Simulate a 1D beam with the help of datas from simulation.</span>

<span class="sd">    Compute the beam density from the equilibrium data on a mesh.</span>
<span class="sd">    The beam density is not very sensitive from the fluctuation, therefore</span>
<span class="sd">    only the central line is computed and a gaussian profile is assumed (with a different</span>
<span class="sd">    vertical and horizontal width).</span>
<span class="sd">    When computing a beam density outside the mesh, an interpolation is made (cubic).</span>
<span class="sd">    Two ways of computing the emission exists, a first one by assuming that</span>
<span class="sd">    the lifetime of the excited state is negligible (thus only the datas from the point </span>
<span class="sd">    considered are used) and a second one that compute the expected value</span>
<span class="sd">    from an exponential decay.</span>
<span class="sd">    The simulation data are saved in this class.</span>

<span class="sd">    :param str config_file: Name of the config file</span>

<span class="sd">    :var str self.cfg_file: Name of the config file</span>
<span class="sd">    :var str self.adas_atte: Name of the ADAS21 files (beam stopping coefficient)</span>
<span class="sd">    :var str self.adas_emis: Name of the ADAS22 files (emission coefficient)</span>
<span class="sd">    </span>
<span class="sd">    :var self.collisions: :class:`Collisions &lt;FPSDP.Plasma.Collisions.collisions.Collisions&gt;` instance variable.\</span>
<span class="sd">    Compute all the coefficients (beam stopping and emission) for the diagnostic.</span>

<span class="sd">    :var list[list[int,int]] self.coll_atte: List of couple between a ADAS21 file \</span>
<span class="sd">    (beam stopping coefficient) and a beam component (in this order)</span>
<span class="sd">    :var list[list[int,int]] self.coll_emis: List of couple between a ADAS21 file \</span>
<span class="sd">    (emission coefficient) and a beam component (in this order)</span>
<span class="sd">    </span>
<span class="sd">    :var int self.Nlt: Number of point for the mesh in the lifetime effect</span>
<span class="sd">    :var float elf.t_max: Cut-off for the integral of the liftetime effect\</span>
<span class="sd">    (in unit of the lifetime)</span>

<span class="sd">    :var np.array[Ncomp] self.mass_b: Mass of a particule in the beam (one for\</span>
<span class="sd">    each beam component) in amu</span>
<span class="sd">    :var np.array[Ncomp] self.beam_comp: Beam energy of each component (in eV)</span>

<span class="sd">    :var float self.power: Total power of the laser (in W)</span>
<span class="sd">    :var np.array[Ncomp] self.frac: Fraction of energy of each beam component (in percent)</span>
<span class="sd">    :var np.array[3] self.pos: Position of the beam source (in cartesian system) in m</span>
<span class="sd">    :var np.array[3] self.direc: Direction of the beam (unit vector)</span>
<span class="sd">    :var float self.beam_width_h: Horizontal beam width (FWHM) in m</span>
<span class="sd">    :var float self.beam_width_v: Vertical beam width (FWHM) in m</span>
<span class="sd">    :var float self.stddev_h: Horizontal beam width (standard deviation)</span>
<span class="sd">    :var float self.stddev_v: Vertical beam width (standard deviation)</span>
<span class="sd">    :var float self.stddev2_h: Square Horizontal beam width (standard deviation)</span>
<span class="sd">    :var float self.stddev2_v: Square Vertical beam width (standard deviation)</span>

<span class="sd">    :var np.array[Ncomp] self.speed: Speed of the particles of each component\</span>
<span class="sd">    (does not take relativity in account)</span>
<span class="sd">    :var self.data: Data from a loader (Actually only XGC datas are accepted)</span>
<span class="sd">    :var np.array[3] self.inters: Ending 3D point of the mesh (intersection with\</span>
<span class="sd">    the limit of the optical system)</span>
<span class="sd">    :var int self.Nz: Number of point for the discretization of the beam</span>
<span class="sd">    :var np.array[Nz] self.dl: Distance between the origin and each point of the mesh</span>
<span class="sd">    :var np.array[Nz,3] self.mesh: Position of the mesh points (in cartesian system)</span>
<span class="sd">    :var np.array[Ncomp,Nz] self.density_beam: Particle density of each component\</span>
<span class="sd">    on the mesh</span>
<span class="sd">    :var list[tck_interp] self.nb_tck: Interpolant for each component (use cubic spline)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">config_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Load everything from the config file&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cfg_file</span> <span class="o">=</span> <span class="n">config_file</span>                                          <span class="c">#!</span>
        <span class="k">print</span> <span class="s">&#39;Reading config file (beam)&#39;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">psr</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
        <span class="n">config</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg_file</span><span class="p">)</span>

        <span class="c"># The example input is well commented</span>
        
        <span class="c"># load data for collisions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adas_atte</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Collisions&#39;</span><span class="p">,</span><span class="s">&#39;adas_atte&#39;</span><span class="p">))</span>    <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adas_emis</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Collisions&#39;</span><span class="p">,</span><span class="s">&#39;adas_emis&#39;</span><span class="p">))</span>    <span class="c">#!</span>
        <span class="n">n_low</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Collisions&#39;</span><span class="p">,</span><span class="s">&#39;n_low&#39;</span><span class="p">))</span>
        <span class="n">n_high</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Collisions&#39;</span><span class="p">,</span><span class="s">&#39;n_high&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collisions</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">Collisions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adas_atte</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">adas_emis</span><span class="p">,</span>
                                         <span class="p">(</span><span class="n">n_low</span><span class="p">,</span><span class="n">n_high</span><span class="p">))</span>                     <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coll_atte</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Collisions&#39;</span><span class="p">,</span><span class="s">&#39;coll_atte&#39;</span><span class="p">))</span>    <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coll_emis</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Collisions&#39;</span><span class="p">,</span><span class="s">&#39;coll_emis&#39;</span><span class="p">))</span>    <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nlt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Collisions&#39;</span><span class="p">,</span><span class="s">&#39;Nlt&#39;</span><span class="p">)))</span>           <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_max</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Collisions&#39;</span><span class="p">,</span><span class="s">&#39;t_max&#39;</span><span class="p">))</span>            <span class="c">#!</span>
        

        <span class="c"># load data about the beam energy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass_b</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Beam energy&#39;</span><span class="p">,</span><span class="s">&#39;mass_b&#39;</span><span class="p">))</span>         <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass_b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Beam energy&#39;</span><span class="p">,</span><span class="s">&#39;E&#39;</span><span class="p">))</span>           <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Beam energy&#39;</span><span class="p">,</span><span class="s">&#39;power&#39;</span><span class="p">))</span>                <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frac</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Beam energy&#39;</span><span class="p">,</span><span class="s">&#39;f&#39;</span><span class="p">))</span>                <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span> <span class="c"># allow the possibility to simulate only</span>
            <span class="c"># a part of the beam</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;Sum of f is greater than 100&#39;</span><span class="p">)</span>

        <span class="c"># load data about the geometry of the beam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Beam geometry&#39;</span><span class="p">,</span><span class="s">&#39;position&#39;</span><span class="p">))</span>        <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direc</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Beam geometry&#39;</span><span class="p">,</span><span class="s">&#39;direction&#39;</span><span class="p">))</span>     <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direc</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direc</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beam_width_h</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span>
            <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Beam geometry&#39;</span><span class="p">,</span><span class="s">&#39;beam_width_h&#39;</span><span class="p">))</span>                      <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beam_width_v</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span>
            <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Beam geometry&#39;</span><span class="p">,</span><span class="s">&#39;beam_width_v&#39;</span><span class="p">))</span>                      <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Beam geometry&#39;</span><span class="p">,</span><span class="s">&#39;Nz&#39;</span><span class="p">))</span>                      <span class="c">#!</span>

        <span class="c"># get the standard deviation at the origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stddev_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_width_h</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)))</span>     <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stddev_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_width_v</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)))</span>     <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stddev2_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stddev_h</span><span class="o">**</span><span class="mi">2</span>                                    <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stddev2_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stddev_v</span><span class="o">**</span><span class="mi">2</span>                                    <span class="c">#!</span>

        <span class="c"># speed of each beam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="p">))</span>                           <span class="c">#!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="o">*</span><span class="mf">9.6485383e7</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">mass_b</span><span class="p">)</span>



<div class="viewcode-block" id="Beam1D.set_data"><a class="viewcode-back" href="../../../../FPSDP.Diagnostics.Beam.html#FPSDP.Diagnostics.Beam.beam.Beam1D.set_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Second part of the initialization (should be called manually!).</span>

<span class="sd">        Due to the computation of the limits (:func:`FPSDP.Diagnostics.BES.bes.BES.compute_limits`),</span>
<span class="sd">        the data are loaded after the initialization.</span>
<span class="sd">        This method save the data inside the instance and compute the beam density on the mesh</span>

<span class="sd">        :param data: Loader of the simulation datas</span>
<span class="sd">        :type data: e.g. :class:`FPSDP.Plasma.XGC_Profile.load_XGC_BES.XGC_Loader_BES`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>                                                     <span class="c">#!</span>
        <span class="k">print</span> <span class="s">&#39;Creating mesh&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_mesh</span><span class="p">()</span>
        <span class="k">print</span> <span class="s">&#39;Computing density of the beam&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_beam_on_mesh</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Beam1D.get_width"><a class="viewcode-back" href="../../../../FPSDP.Diagnostics.Beam.html#FPSDP.Diagnostics.Beam.beam.Beam1D.get_width">[docs]</a>    <span class="k">def</span> <span class="nf">get_width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute the beam width at a specific distance.</span>

<span class="sd">        Can be modify for adding the effect of the beam divergence.</span>
<span class="sd">        </span>
<span class="sd">        :param dist: Distance from the origin of the beam</span>
<span class="sd">        :type dist: np.array[N]</span>
<span class="sd">    </span>
<span class="sd">        :returns: Horizontal and vertical beam width (0 for horizontal, 1 for vertical)</span>
<span class="sd">        :rtype: np.array[2,dist.shape]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">stddev_h</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">stddev_v</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">shape</span><span class="p">)])</span>
</div>
<div class="viewcode-block" id="Beam1D.create_mesh"><a class="viewcode-back" href="../../../../FPSDP.Diagnostics.Beam.html#FPSDP.Diagnostics.Beam.beam.Beam1D.create_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">create_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create the 1D mesh between the source of the beam and the end </span>
<span class="sd">            of the mesh.</span>

<span class="sd">        Is called during the initialization</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># intersection between end of mesh and beam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_wall</span><span class="p">()</span>                                       <span class="c">#!</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">inters</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="c"># distance to the origin along the central line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">length</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Nz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>                                    <span class="c">#!</span>
        <span class="c"># the second index corresponds to the dimension (X,Y,Z)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dl</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">direc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>              <span class="c">#!</span>
        
                    </div>
<div class="viewcode-block" id="Beam1D.find_wall"><a class="viewcode-back" href="../../../../FPSDP.Diagnostics.Beam.html#FPSDP.Diagnostics.Beam.beam.Beam1D.find_wall">[docs]</a>    <span class="k">def</span> <span class="nf">find_wall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Find the wall (of the mesh) that will stop the beam and return</span>
<span class="sd">        the coordinate of the intersection with the beam.</span>
<span class="sd">        </span>
<span class="sd">        :param float eps: Ratio of increase size on each side of the box</span>
<span class="sd">        :returns: Position of the intersection between the end of the mesh and the beam</span>
<span class="sd">        (in cartesian system)</span>
<span class="sd">        :rtype: np.array[3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># X-direction</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">tx1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">tx2</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tx1</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Xmax</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">direc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">tx2</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Xmin</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">direc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c"># Y-directio</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">ty1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">ty2</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ty1</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Zmax</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">direc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ty2</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Zmin</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">direc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c"># Z-direction</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">tz1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">tz2</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tz1</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Ymax</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">direc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">tz2</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Ymin</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">direc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">t_</span> <span class="o">=</span> <span class="p">[</span><span class="n">tx1</span><span class="p">,</span><span class="n">tx2</span><span class="p">,</span><span class="n">ty1</span><span class="p">,</span><span class="n">ty2</span><span class="p">,</span><span class="n">tz1</span><span class="p">,</span><span class="n">tz2</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">t_</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">direc</span><span class="o">*</span><span class="n">t_</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">eps</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Beam1D.get_quantities"><a class="viewcode-back" href="../../../../FPSDP.Diagnostics.Beam.html#FPSDP.Diagnostics.Beam.beam.Beam1D.get_quantities">[docs]</a>    <span class="k">def</span> <span class="nf">get_quantities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">t_</span><span class="p">,</span><span class="n">quant</span><span class="p">,</span><span class="n">eq</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute the quantities from the datas</span>
<span class="sd">        </span>
<span class="sd">        Use the list of string quant for taking the good values inside the simulation datas.</span>
<span class="sd">        See :func:`interpolate_data &lt;FPSDP.Plasma.XGC_Profile.load_XGC_BES.XGC_Loader_BES.interpolate_data&gt;`</span>

<span class="sd">        </span>
<span class="sd">        :param np.array[N,3] pos: List of position where to take the quantities (in cartesian system)</span>
<span class="sd">        :param int t_: Time step considered</span>
<span class="sd">        :param list[str] quant: List containing the wanted quantities \</span>
<span class="sd">        (See :func:`interpolate_data &lt;FPSDP.Plasma.XGC_Profile.load_XGC_BES.XGC_Loader_BES.interpolate_data&gt;`\</span>
<span class="sd">        for more information)</span>
<span class="sd">        :param bool eq: Equilibrium data or not</span>

<span class="sd">        :returns: The interpolated value from the simulation in the same order than quant</span>
<span class="sd">        :rtype: tuple[quant]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;Only one time should be given&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">interpolate_data</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="n">t_</span><span class="p">,</span><span class="n">quant</span><span class="p">,</span><span class="n">eq</span><span class="p">)</span>
        
        </div>
<div class="viewcode-block" id="Beam1D.compute_beam_on_mesh"><a class="viewcode-back" href="../../../../FPSDP.Diagnostics.Beam.html#FPSDP.Diagnostics.Beam.beam.Beam1D.compute_beam_on_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">compute_beam_on_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">eq</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot; Compute the beam density on the mesh and the interpolant.</span>

<span class="sd">        Use the Gauss-Legendre quadrature of order 3 for computing the integral:</span>
<span class="sd">        :math:`n_b(P) = n_{b,0} \exp\left(-\int_0^P n_e(z)S_\text{cr}(E,n_e(z),T_i(z))\sqrt{\frac{m}{2E}}\mathrm{d}z\right)`</span>
<span class="sd">        where :math:`n_b(P)` is the density at the point P (along the beam central line),</span>
<span class="sd">        :math:`n_{b,0}` is the density at the origin, :math:`n_e` is the electron density,</span>
<span class="sd">        :math:`S_\text{cr}` is the beam stopping coefficient (depending on the beam energy [:math:`E_b`],</span>
<span class="sd">        the ion temperature [:math:`T_i`] and the electron density), :math:`m` is the mass of a particle in the beam,</span>
<span class="sd">        :math:`\mathrm{d}z` is along the central line.</span>

<span class="sd">        The initial density is computed with the help of the total power (:math:`P`):</span>
<span class="sd">        :math:`P = \int_\Omega E v n_{b,0} \mathrm{d}\sigma` </span>
<span class="sd">        where :math:`\Omega` is the 2D space perpendicular to the beam direction and</span>
<span class="sd">        :math:`v = \sqrt{\frac{m}{2E}}` is the velocity of the particles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">density_beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">Nz</span><span class="p">))</span>  <span class="c">#!</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;If keep attenuation with eq, should remove time loop&#39;</span><span class="p">)</span>
        <span class="c"># density of the beam at the origin</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="p">))</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">mass_b</span><span class="o">*</span><span class="mf">1.660538921e-27</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">power</span>
        <span class="n">n0</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frac</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="o">*</span><span class="mf">1.60217733e-19</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
        
        <span class="c"># define the quadrature formula for this method</span>
        <span class="n">quad</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">integration_points</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;GL3&#39;</span><span class="p">)</span> <span class="c"># Gauss-Legendre order 3</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])):</span>
            <span class="c"># density over the central line (usefull for some check)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="ow">is</span> <span class="ow">not</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">temp_beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_atte</span><span class="p">:</span>
                    <span class="n">file_nber</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">beam_nber</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c"># limit of the integral</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span>
                    <span class="c"># average</span>
                    <span class="n">av</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
                    <span class="c"># difference</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
                    <span class="c"># integration point</span>
                    <span class="n">pt</span> <span class="o">=</span> <span class="n">quad</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">diff</span> <span class="o">+</span> <span class="n">av</span>
                    <span class="c"># compute all the values needed for the integral</span>
                    <span class="n">ne</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_quantities</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span><span class="bp">None</span><span class="p">,[</span><span class="s">&#39;ne&#39;</span><span class="p">,</span><span class="s">&#39;Ti&#39;</span><span class="p">],</span><span class="n">eq</span><span class="p">)</span>
                    
                    <span class="c"># attenuation coefficient from adas</span>
                    <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collisions</span><span class="o">.</span><span class="n">get_attenutation</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="p">[</span><span class="n">beam_nber</span><span class="p">],</span><span class="n">ne</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mass_b</span><span class="p">[</span><span class="n">beam_nber</span><span class="p">],</span>
                        <span class="n">T</span><span class="p">,</span><span class="n">file_nber</span><span class="p">)</span>
                    
                    <span class="c"># half distance between a &amp; b</span>
                    <span class="n">norm_</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                    <span class="n">temp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ne</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">quad</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>
                    <span class="n">temp1</span> <span class="o">*=</span> <span class="n">norm_</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">speed</span><span class="p">[</span><span class="n">beam_nber</span><span class="p">]</span>
                    <span class="n">temp_beam</span><span class="p">[</span><span class="n">beam_nber</span><span class="p">]</span> <span class="o">+=</span> <span class="n">temp1</span>
                    
                <span class="bp">self</span><span class="o">.</span><span class="n">density_beam</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">density_beam</span><span class="p">[:,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> \
                                                <span class="n">temp_beam</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nb_tck</span> <span class="o">=</span> <span class="p">[]</span>                                                     <span class="c">#!</span>
        <span class="c"># interpolant for the beam</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">density_beam</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">n0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">density_beam</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nb_tck</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolate</span><span class="o">.</span><span class="n">splrep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">density_beam</span><span class="p">[</span><span class="n">i</span><span class="p">,:]))</span>
                
            </div>
<div class="viewcode-block" id="Beam1D.get_mesh"><a class="viewcode-back" href="../../../../FPSDP.Diagnostics.Beam.html#FPSDP.Diagnostics.Beam.beam.Beam1D.get_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">get_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Acces method to the mesh</span>

<span class="sd">        :returns: self.mesh</span>
<span class="sd">        :rtype: np.array[Nz,3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
</div>
<div class="viewcode-block" id="Beam1D.get_origin"><a class="viewcode-back" href="../../../../FPSDP.Diagnostics.Beam.html#FPSDP.Diagnostics.Beam.beam.Beam1D.get_origin">[docs]</a>    <span class="k">def</span> <span class="nf">get_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Acces method to the origin of the beam</span>

<span class="sd">        :returns: self.pos (in cartesian system)</span>
<span class="sd">        :rtype: np.array[3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
</div>
<div class="viewcode-block" id="Beam1D.get_beam_density"><a class="viewcode-back" href="../../../../FPSDP.Diagnostics.Beam.html#FPSDP.Diagnostics.Beam.beam.Beam1D.get_beam_density">[docs]</a>    <span class="k">def</span> <span class="nf">get_beam_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute the beam density with the help of the interpolant.</span>
<span class="sd">        </span>
<span class="sd">        Change the coordinate of the position from the cartesian system to</span>
<span class="sd">        the beam system and, after, interpolate the data.</span>

<span class="sd">        :param np.array[...,3] pos: List of position where to take the\</span>
<span class="sd">        beam density (in cartesian system)</span>

<span class="sd">        :returns: Beam density</span>
<span class="sd">        :rtype: np.array[:]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pos</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="c"># vector from beam origin to the wanted position</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_origin</span><span class="p">()</span>
        <span class="c"># result is a 1D array containing the projection of the distance</span>
        <span class="c"># from the origin over the direction of the beam</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;ij,j-&gt;i&#39;</span><span class="p">,</span><span class="n">dist</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">direc</span><span class="p">)</span>
        <span class="n">stddev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_width</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
        <span class="n">stddev2</span> <span class="o">=</span> <span class="n">stddev</span><span class="o">**</span><span class="mi">2</span>
        
        <span class="c"># cubic spline for finding the value along the axis</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">nb</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">proj</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_tck</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ext</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c"># radius^2 on the plane perpendicular to the beam</span>
        <span class="n">R2</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">-</span> <span class="n">proj</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">direc</span>
        <span class="c"># compute the norm of each position</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">R2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="n">nb</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">xy</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">stddev2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">z</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">stddev2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="p">(</span>
            <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">stddev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">stddev</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">nb</span>

                    
        </div>
<div class="viewcode-block" id="Beam1D.get_emis"><a class="viewcode-back" href="../../../../FPSDP.Diagnostics.Beam.html#FPSDP.Diagnostics.Beam.beam.Beam1D.get_emis">[docs]</a>    <span class="k">def</span> <span class="nf">get_emis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">t_</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot; Compute the emission at a given position and time step</span>

<span class="sd">        :math:`\varepsilon = \langle\sigma v\rangle n_b n_e`</span>
<span class="sd">       </span>
<span class="sd">        :param np.array[N,3] pos: Position in the cartesian system</span>
<span class="sd">        :param float t_: Time step</span>

<span class="sd">        :returns: :math:`\varepsilon`</span>
<span class="sd">        :rtype: np.array[N]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># first take all the value needed for the computation</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
        <span class="n">emis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="p">),</span><span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">n_e</span><span class="p">,</span><span class="n">Ti</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_quantities</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="n">t_</span><span class="p">,[</span><span class="s">&#39;ne&#39;</span><span class="p">,</span><span class="s">&#39;Ti&#39;</span><span class="p">])</span>
        <span class="c"># loop over all the type of collisions</span>
        <span class="n">n_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_beam_density</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_emis</span><span class="p">:</span>
            <span class="n">file_nber</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">beam_nber</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># compute the emission coefficient</span>
            <span class="n">emis</span><span class="p">[</span><span class="n">beam_nber</span><span class="p">,:]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collisions</span><span class="o">.</span><span class="n">get_emission</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="p">[</span><span class="n">beam_nber</span><span class="p">],</span><span class="n">n_e</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mass_b</span><span class="p">[</span><span class="n">beam_nber</span><span class="p">],</span><span class="n">Ti</span><span class="p">,</span><span class="n">file_nber</span><span class="p">)</span>
        <span class="c"># compute the emissivity</span>
        <span class="n">emis</span> <span class="o">=</span> <span class="n">emis</span><span class="o">*</span><span class="n">n_e</span><span class="o">*</span><span class="n">n_b</span>
        <span class="k">return</span> <span class="n">emis</span>

</div>
<div class="viewcode-block" id="Beam1D.get_emis_lifetime"><a class="viewcode-back" href="../../../../FPSDP.Diagnostics.Beam.html#FPSDP.Diagnostics.Beam.beam.Beam1D.get_emis_lifetime">[docs]</a>    <span class="k">def</span> <span class="nf">get_emis_lifetime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">t_</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot; Compute the emission at a given position and time step</span>

<span class="sd">        For the density of excited particles, the following formula is used:</span>
<span class="sd">        :math:`n_\text{ex} = \frac{1}{\|v\|}\int_0^{\tau vd} \varepsilon(P-\delta \hat{v})\exp\left(-\frac{\delta}{v\tau}\right)\mathrm{d}\delta`</span>
<span class="sd">        where :math:`v` is the velocity of the beam particles (:math:`\hat{v} = \frac{\vec{v}}{\|\vec{v}\|}`),</span>
<span class="sd">        :math:`\varepsilon` is the emissivity computed in :func:`get_emis &lt;FPSDP.Diagnostics.Beam.beam.Beam1D.get_emis&gt;`, and</span>
<span class="sd">        :math:`\tau` is the lifetime.</span>

<span class="sd">        Therefore the emissivity is given by:</span>
<span class="sd">        :math:`\varepsilon_l(P) = \frac{n_\text{ex}(P)}{\tau}`</span>
<span class="sd">       </span>
<span class="sd">        :param np.array[N,3] pos: Position in the cartesian system</span>
<span class="sd">        :param float t_: Time step</span>

<span class="sd">        :returns: :math:`\varepsilon_l`</span>
<span class="sd">        :rtype: np.array[N]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span> <span class="s">&#39;wavelength!!!&#39;</span>

        <span class="n">quad</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">integration_points</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;GL19&#39;</span><span class="p">)</span> <span class="c"># Gauss-Legendre order 3</span>
        <span class="n">emis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="p">),</span><span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="c"># avoid the computation at each time</span>
        <span class="n">ne_in</span><span class="p">,</span> <span class="n">Ti_in</span><span class="p">,</span><span class="n">Te_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_quantities</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="n">t_</span><span class="p">,[</span><span class="s">&#39;ne&#39;</span><span class="p">,</span><span class="s">&#39;Ti&#39;</span><span class="p">,</span><span class="s">&#39;Te&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_emis</span><span class="p">:</span>
            <span class="n">file_nber</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">beam_nber</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># loop over all the position</span>
            <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collisions</span><span class="o">.</span><span class="n">get_lifetime</span><span class="p">(</span><span class="n">ne_in</span><span class="p">,</span><span class="n">Te_in</span><span class="p">,</span><span class="n">Ti_in</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="p">[</span><span class="n">beam_nber</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">mass_b</span><span class="p">[</span><span class="n">beam_nber</span><span class="p">],</span><span class="n">file_nber</span><span class="p">)</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">pos</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
            <span class="c"># used for avoiding the discontinuity before the origin</span>
            <span class="c"># of the beam</span>
            <span class="n">up_lim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">l</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">t_max</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">speed</span><span class="p">[</span><span class="n">beam_nber</span><span class="p">],</span><span class="n">dist</span><span class="p">)</span>

            <span class="c"># split the distance in interval</span>
            <span class="c"># copy and modify the source code of linspace</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">up_lim</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nlt</span><span class="p">)</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">step</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nlt</span><span class="p">)</span>\
                    <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            
            <span class="c"># average position (a+b)/2</span>
            <span class="n">av</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">delta</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:])</span>
            <span class="c"># half distance (b-a)/2</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">delta</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:])</span>
            <span class="c"># integration points at each interval</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">av</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">diff</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">quad</span><span class="o">.</span><span class="n">pts</span>

            <span class="c"># points in 3D space</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span> \
                <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">direc</span>

            <span class="n">n_e</span><span class="p">,</span> <span class="n">Ti</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_quantities</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t_</span><span class="p">,[</span><span class="s">&#39;ne&#39;</span><span class="p">,</span><span class="s">&#39;Ti&#39;</span><span class="p">])</span>

            <span class="n">n_e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_e</span><span class="p">,</span><span class="n">pt</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">Ti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Ti</span><span class="p">,</span><span class="n">pt</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="n">n_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_beam_density</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">beam_nber</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
            <span class="n">n_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_b</span><span class="p">,</span><span class="n">pt</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        
            
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collisions</span><span class="o">.</span><span class="n">get_emission</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_comp</span><span class="p">[</span><span class="n">beam_nber</span><span class="p">],</span><span class="n">n_e</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                                             <span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mass_b</span><span class="p">[</span><span class="n">beam_nber</span><span class="p">],</span><span class="n">Ti</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span><span class="n">file_nber</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">pt</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            
            <span class="n">f</span> <span class="o">=</span> <span class="n">n_b</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">n_e</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">pt</span><span class="o">/</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">speed</span><span class="p">[</span><span class="n">beam_nber</span><span class="p">]))</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">speed</span><span class="p">[</span><span class="n">beam_nber</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;Mesh not well computed&#39;</span><span class="p">)</span>
            
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;kmn,n-&gt;km&#39;</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">quad</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>

            <span class="n">emis</span><span class="p">[</span><span class="n">beam_nber</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span><span class="o">*</span><span class="n">f</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">l</span>
        <span class="k">return</span> <span class="n">emis</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../FPSDP.html">BES 0.8 documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Loic Hausammann.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>