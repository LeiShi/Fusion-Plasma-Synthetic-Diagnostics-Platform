/*! \file reflectometer.c
  \brief Top-level reflectometery interface functions
  
  Call after the "CALL SETUP" and before the "CALL mpi_finalize"
  in the main fortran file.  Example:
  For 2D profile data: "CALL reflectometer_profiles"
*/


/*! \mainpage Reflectometer Interface Guide
     \author Erik Granstedt 
     \date Summer 2008
     \section intro_sec Introduction
 
     This manual describes how to use the reflectometer interface to the GTS gyrokinetic code.
     This interface extracts the profile and/or fluctuations data from a GTS run so that it can
     be used with either the 2D or 3D reflectometery code.
 
     \section usage_sec Usage
 
      \subsection step1 Step 1: Determining what is needed

      The first question that must be asked is: "Do we want 2D data at a single toroidal position
      (poloidal slice), or do we need 3D data?"
      
      The second question to ask is "Do we want the data at particular points and particular
      timesteps or are we ok with
      data on a regular grid at arbitrary (given) positions? (at a single timestep only)"

      The final question to ask is "Do we need fluctuation data also, or just the profiles?"

      \subsection step2 Step 2: GTS interface
      
      Answering the three questions above uniquely determines the top level function that
      needs to be called during the GTS setup.  A single function call must be inserted between
      the "CALL SETUP" and before the "CALL mpi_finalize" calls in the main fortran file.
      For example, if we want 2D profile data at unspecified grid points, we would insert:
      "CALL reflectometer_2d_regular_profiles" and then recompile the GTS setup.  Run the
      GTS setup via a command such as: "mpirun -np 1 test_setup".

      The eight top-level functions are:
       -  reflectometer_2d_regular_profiles
       -  reflectometer_2d_regular_all
       -  reflectometer_2d_specified_profiles
       -  reflectometer_2d_specified_all
       -  reflectometer_3d_regular_profiles
       -  reflectometer_3d_regular_all
       -  reflectometer_3d_specified_profiles
       -  reflectometer_3d_specified_all


      There are a few caveats: if fluctuation data is needed, then in addition,
      the reflectometer interface needs to find certain files by the time it is called at
      the end of the GTS setup:
      
 
      -  ``dsda_psi.dat'' in the same directory as the INPUT.d file.  This file is
       generated by the GTS setup and is ready to be read by the time the reflectometer
       interface needs it. The reflectometer interface assumes a known format for this file,
       so if this format changes, the interface may no longer be able to read the "psi" grid
       (grid of flux surfaces) and will fail.
       
      -  ``fluctuations/PHI.xxxxx'' These files contain the potential fluctuations at a single
      toroidal location.  The index for this toroidal location starts at 0 ("PHI.00000") and
      extends to ntoroidal-1 (ex. "PHI.00063" if ntoroidal = 64).  The variable "ntoroidal"
      is determined from the first potential file "PHI,00000".  If any of these files
      are missing, the reflectometer function will abort with an error
  

      \subsection step3 Step 3: Specifying grid points

      If the reflectometer interface is to be used with specified grid points, then the
      interface expects to find a file titled: reflectometer_#d_points.cdf in the directory
      in which the gts setup program is run (where # is 2 or 3 depending on whether a 2d or
      3d top-level function is being called).  In addition, the interface expects the
      following dimensions and variables:
      
      -  2d in reflectometer_2d_points.cdf:
	  -  dimensions: r_dim, z_dim, timesteps_dim
	  -  variables: r[r_dim], z[z_dim], timesteps[timesteps_dim], zeta

      -  3d in reflectometer_3d_points.cdf:
         -  dimensions: x_dim, y_dim, z_dim, timesteps_dim
	  -  variables: x[x_dim], y[y_dim], z[z_dim], timesteps[timesteps_dim]
      
      An advantage of using the specified coordinates when looking at 2d data with fluctuations
      is that the scalar variable zeta can be specified.  This corresponds to the toroidal
      angle of the 2d (poloidal) plane.  Otherwise, the macro "FLUC_2D_ZETA" has to be changed
      in the "reflectometer.c" file, and everything recompiled.
   
    \section errors_sec Possible Errors

     In addition to the modules for the GTS setup, the reflectometer interface also requires
     the "netcdf" and "gsl" modules to be loaded.

     When called, the reflectometer interface does the following:
      -# Generates a regular grid or meshes a grid from 1d arrays in the coordinates file.  If the interface is
         called to use specified coordinates, and a coordinates file cannot be found, the program will quit
	 with an error.
      -# Performs an iterative root solve to find the flux coordinates (a,theta) that correspond to the desired
         cylindrical coordinates (R,Z).  If the root solver fails to converge to the desired accuracy for a particular
	 point, the program will output a warning identifying the erroneous point and the error, then continue
	 execution.  For some equilibria, points outside the last-closed-flux-surface do not get mapped correctly;
	 for other equilibria, this is not a problem.  For a visual picture of the success of the coordinate mapping
	 use the ``coord_posn.py'' Python program described later.
      -# Evaluates the profile variables (|B|, Bpol, q, ne0, P, Ti, Te) at these points.  Naturally, these values
         are calculated at the positions returned by the root solver, so if the root solver fails, then these points
	 correspond to the ``actual'' returned coordinates, not the ``desired'' coordinates we were hoping to get.
      -# If fluctuation data is requested, reads in the ``dsda_psi.dat'' and ``fluctuations/PHI.xxxxx'' files.  If
         these files cannot be found, or if the format of these files differs from the known format, the program quits
	 with an error.  Next, the program performs linear interpolation along the field line to determine the value
	 of the potential fluctuation at these points.  Finally, assumes an electron adiabatic response to
	 calculate ne_tilde and the ``total'' ne.
      -# Stores coordinate, profile, and (optionally) fluctuation data in a netCDF file.  Will quit with an error if
         it cannot write the netCDF file.

   \section visualization_sec Visualization

    Several Python scripts have been written to visualize the output from the reflectometer interface and make sure it
    is working correctly.  To function, the ``python/scipy'' module must be loaded.  They can be executed either
    directly from the shell as any shell script would be, or they can be executed interactively, by first calling
    ``ipython -pylab'', then at the ipython prompt ``run <scriptname.py>''.  Interactive execution allows one to
    view and interact with data variables after the script returns.  Available scripts include:

    - coord_posn.py: use for evaluating the success of the coordinate mapping
    - profiles_plot.py: use for viewing the profile information
    - phi_plot.py: use for viewing the potential fluctuation
    - reflect2d_plot.py: use for viewing the output from the 2d reflectometry code
    - reflect3d_plot.py: use for viewing the output from the 2d reflectometry code

    Running any of these scripts with no arguments will return usage information for each one.

 */



#ifndef reflectometer_c
#define reflectometer_c

#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#define DEBUG 0			// set > 0 to put debugging output to stderr
#define VERBOSE 1		// set > 0 to put general info to stdout
#define DEVELOPMENT 0		// with debugging output
//#define FLUCTUATIONS 1
#define ERRCODE 2

#ifndef single
#ifndef REAL_TYPEDEF			// compiler option determines variable size
#define REAL_TYPEDEF
typedef double REAL;
#endif
#define MPI_RSIZE MPI_DOUBLE
#else
#ifndef REAL_TYPEDEF
#define REAL_TYPEDEF
typedef float REAL;
#endif
#define MPI_RSIZE MPI_FLOAT
#endif


// the external functions used to get the profile information
extern int esigetprofiles(REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *);
extern int esigetrzb_(REAL *,REAL *,REAL *,REAL *,REAL *,int *);
extern int esilink2c_(REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *,REAL *);
extern int esiget2dfunctions_(REAL *,REAL *,int *);
extern int esifree();

// local includes
#include "interp.h"		// interpolation functions for setting up initial guess
#include "fileio.h"		// file i/o
#include "profile_coord_map.h"	// coordinate mapping
#include "fluc.h"


// local function declarations
int reflectometer_fluc_coords(REAL mag_axis_coords[]); // deprecated function

/* fortran compatibility
#define reflectometer_profiles reflectometer_profiles_ // needed so that it can be called by fortran
#define reflectometer_2d_regular_profiles reflectometer_2d_regular_profiles_
#define reflectometer_2d_regular_all reflectometer_2d_regular_all_
#define reflectometer_2d_specified_profiles reflectometer_2d_specified_profiles_
#define reflectometer_2d_specified_all reflectometer_2d_specified_all_
#define reflectometer_3d_regular_profiles reflectometer_3d_regular_profiles_
#define reflectometer_3d_regular_all reflectometer_3d_regular_all_
#define reflectometer_3d_specified_profiles reflectometer_3d_specified_profiles_
#define reflectometer_3d_specified_all reflectometer_3d_specified_all_
*/

// files to read
// used by the 2d and 3d "specified" functions: the file name for the specified coordinates
#define COORD_FILE_2D "coords_2d.cdf"
#define COORD_FILE_3D "coords_3d.cdf"
#define FLUC_FNAME "fluctuations.cdf" // deprecated
const char* NTFILENAME="NTprofile.cdf";

// files to write
#define NETCDF_FILE_2D "reflectometer_profiles_2D.cdf" 
#define NETCDF_FILE_3D "reflectometer_profiles_3D.cdf"
#define FLUC_FILE_HEAD "fluctuation"
// file names for netcdf and text data

// used by reflectometer_2d_regular_all and reflectometer_2d_regular_profiles
#define NR 201			//total # of points is NR*NZ
#define NZ 201
#define FLUC_2D_ZETA 0.1	// used by reflectometer_2d_regular_all for the zeta coord

// used by reflectometer_3d_regular_all and reflectometer_3d_regular_profiles
#define Nx 64
#define Ny 64
#define Nz 8

// if using "regular" grid points, we just want 1 timestep
#define N_TIME_STEPS 50
#define TIME_START 2000
#define TIME_END 3000


const int NBOUNDARY=1001;		// number of boundary points used by all top-level functions

//----- local function definitions

//! Top-level function to store the 2D profile data in a netCDF file
/*! Generates a regular 2D grid in (R,Z) and stores the following
  quantities at those grid points:
  |B|, Bpol, P, ne, Te, Ti, q
*/
int reflectometer_2d_regular_profiles(){
  fprintf(stderr,"started reflectometer_2d_regular_profiles\n");

  // get the position of the magnetic axis
  REAL mag_axis_coords[2];	// (R,Z) of the magnetic axis
  int k = get_mag_axis(mag_axis_coords);

  // set up the grid of points we want: an even grid in (R,Z)
  int nr=NR;			// number of points in 1d array
  int nz = NZ;
  int n2d = nr*nz; 		// total number of points
  REAL R1d[nr], Z1d[nz];
  REAL Rwant[n2d],Zwant[n2d];	// R,Z cylindrical coords and |B|, used by esigetrzb
  k = desiredrz(Rwant,Zwant,R1d,Z1d,nr,nz,mag_axis_coords[0],mag_axis_coords[1]); // the R,Z points we want
  fprintf(stderr,"initial left corner:(%lf,%lf)\n",Rwant[0],Zwant[0]);
  // get the corresponding flux coords
  REAL a[n2d],theta[n2d],Bm[n2d]; // field-line coords: flux (radial), angle (poloidal), |B|
  REAL Rinitial[n2d],Zinitial[n2d]; // the R,Z values of our initial guess
  REAL Ract[n2d],Zact[n2d];	// actual R,Z coordinates we end up with

  int *InOutFlag = (int *)malloc(n2d*sizeof(int));

/* rz2agq test
  k=ESIrz2agq(a,theta,Rwant,Zwant,InOutFlag,n2d);
  if(k!=0)
    fprintf(stderr,"%d points not good!\n",k);
  k=esigetrzb_(Ract,Zact,Bm,a,theta,&n2d);
    fprintf(stderr,"%d pints not good.\n",k);

  for(k=0;k<n2d;k++)
  {
    double rerr=fabs(Rwant[k]-Ract[k]);
    double zerr=fabs(Zwant[k]-Zact[k]);
//    if(rerr>1e-9 || zerr>1e-9)
      fprintf(stderr,"%d point (%lf,%lf) mapped (%lf,%lf) away\n",k,Rwant[k],Zwant[k],rerr,zerr);
  }
  end test */

  k = getFluxCoords(n2d,a,theta,Bm,Ract,Zact,Rinitial,Zinitial,Rwant,Zwant,mag_axis_coords,InOutFlag);
  fprintf(stderr,"after getflux left corner:(%lf,%lf)\n",Rwant[0],Zwant[0]);
  // get the profiles
  REAL Bpol[n2d],Ti[n2d],Te[n2d],P[n2d],ne0[n2d],qprofile[n2d];
  k = getAllProfiles(n2d,Bpol,Ti,Te,P,ne0,qprofile,a,theta,InOutFlag);
  
  // get boundary coords
  REAL R_bdy[NBOUNDARY],Z_bdy[NBOUNDARY];
  k = getBoundaryPoints(R_bdy,Z_bdy,NBOUNDARY);

  // cause density, temperature to exponentially decay beyond LCFS
  k = decayNToutsideLCFS(n2d,a,ne0,Te,Ti,InOutFlag);
 
  // no fluctuations
  REAL ne_tilde[n2d],phi[n2d];
  int i;
  for(i=0;i<n2d;i++){
    ne_tilde[i] = 0;
    phi[i] = 0;
  }

  int timesteps[N_TIME_STEPS];
  for(i=0;i<N_TIME_STEPS;i++){
    timesteps[i]=TIME_START+(TIME_END-TIME_START)/(N_TIME_STEPS-1)*i;
  }

  // write data to a netcdf file
  k = write2dNetcdfFile(NETCDF_FILE_2D,nr,nz,N_TIME_STEPS,NBOUNDARY,R1d,Z1d,a,theta,Ract,Zact,Bm,Bpol,Ti,Te,P,ne0,ne_tilde,phi,timesteps,Rinitial,Zinitial,qprofile,R_bdy,Z_bdy,mag_axis_coords);

  k = esifree();			// free memory associated with ESI functions
  free(InOutFlag);
  return 0;
}


//! Top-level function to store the 2D profile data in a netCDF file
/*! Generates a regular 2D grid in (R,Z) and stores the following
  quantities at those grid points:
  |B|, Bpol, P, ne, Te, Ti, q
*/
int reflectometer_3d_regular_profiles(){
  fprintf(stderr,"started reflectometer_3d_regular_profiles\n");

  // get the position of the magnetic axis
  REAL mag_axis_coords[2];	// (R,Z) of the magnetic axis
  int k = get_mag_axis(mag_axis_coords);

  // set up the grid of points we want: an even grid in (R,Z)
  int nx=Nx;			// number of points in 1d array
  int ny = Ny;
  int nz = Nz;
  int n3d = nx*ny*nz; 		// total number of points
  REAL x1d[nx],y1d[ny],z1d[nz];		// 1d arrays of the (x,y,z) we want
  REAL xwant[n3d],ywant[n3d],zwant[n3d];	// 3d mesh of the (x,y,z) we want
  k = desiredxyz(nx,ny,nz,x1d,y1d,z1d,xwant,ywant,zwant,mag_axis_coords[0],mag_axis_coords[1]); // the R,Z points we want
  // get the equivalent R,Z,zeta points
  REAL Rwant[n3d],Zwant[n3d],zeta[n3d];
  k = cartesianToCylindrical(n3d,Rwant,Zwant,zeta,xwant,ywant,zwant);

  // get the corresponding flux coords
  REAL a[n3d],theta[n3d],Bm[n3d]; // field-line coords: flux (radial), angle (poloidal), |B|
  REAL Rinitial[n3d],Zinitial[n3d]; // the R,Z values of our initial guess
  REAL Ract[n3d],Zact[n3d];	// actual R,Z coordinates we end up with
  int *InOutFlag = (int *)xmalloc(n3d*sizeof(int));
  k = getFluxCoords(n3d,a,theta,Bm,Ract,Zact,Rinitial,Zinitial,Rwant,Zwant,mag_axis_coords,InOutFlag);

  // get the profiles
  REAL Bpol[n3d],Ti[n3d],Te[n3d],P[n3d],ne0[n3d],qprofile[n3d];
  k = getAllProfiles(n3d,Bpol,Ti,Te,P,ne0,qprofile,a,theta,InOutFlag);

  // get boundary coords
  REAL R_bdy[NBOUNDARY],Z_bdy[NBOUNDARY];
  k = getBoundaryPoints(R_bdy,Z_bdy,NBOUNDARY);

  // cause density, temperature to exponentially decay beyond LCFS
  k = decayNToutsideLCFS(n3d,a,ne0,Te,Ti,InOutFlag);
 
  // no fluctuations
  REAL ne_tilde[n3d],phi[n3d];
  int i;
  for(i=0;i<n3d;i++){
    ne_tilde[i] = 0;
    phi[i] = 0;
  }

  int timesteps[N_TIME_STEPS];
  for(i=0;i<N_TIME_STEPS;i++){
    timesteps[i]=TIME_START+(TIME_END-TIME_START)/(N_TIME_STEPS-1)*i;
  }

  // write data to a netcdf file
  k = write3dNetcdfFile(NETCDF_FILE_3D,nx,ny,nz,N_TIME_STEPS,NBOUNDARY,x1d,y1d,z1d,a,theta,zeta,Rwant,Zwant,Ract,Zact,Bm,Bpol,Ti,Te,P,ne0,ne_tilde,phi,timesteps,Rinitial,Zinitial,qprofile,R_bdy,Z_bdy,mag_axis_coords);

  k = esifree();			// free memory associated with ESI functions

  return 0;
}

//! Top-level function to store the 2D profile data in a netCDF file
/*! Uses the specified 1d arrays in the file given by the macro: ``COORD_FILE_2D''
    to generate a 2D grid in (R,Z) and stores the following
    quantities at those grid points:
    |B|, Bpol, P, ne, Te, Ti, q
*/
int reflectometer_2d_specified_profiles(){
  fprintf(stderr,"started reflectometer_2d_specified_profiles\n");

  // get the position of the magnetic axis
  REAL mag_axis_coords[2];	// (R,Z) of the magnetic axis
  int k = get_mag_axis(mag_axis_coords);

  // set up the grid of points we want: an even grid in (R,Z)
  size_t nr,nz,ntimesteps;
  int *timesteps;
  REAL zeta,*R1d, *Z1d;
  k = readSpecified2dCoordFile(COORD_FILE_2D,&nr,&nz,&ntimesteps,&zeta,&R1d,&Z1d,&timesteps);
 
  int n2d = nr*nz; 		// total number of points
  REAL *Rwant = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *Zwant = (REAL *)xmalloc(n2d*sizeof(REAL));
  k = mesh2dGrid(Rwant,Zwant,R1d,Z1d,nr,nz); // the R,Z points we want

  // get the corresponding flux coords
  REAL *a = (REAL *)xmalloc(n2d*sizeof(REAL)); // flux coords: flux (radial), angle (poloidal), |B|
  REAL *theta = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *Bm = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *Rinitial = (REAL *)xmalloc(n2d*sizeof(REAL)); // the R,Z values of our initial guess
  REAL *Zinitial = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *Ract = (REAL *)xmalloc(n2d*sizeof(REAL)); // actual R,Z coordinates we end up with
  REAL *Zact = (REAL *)xmalloc(n2d*sizeof(REAL));
  int *InOutFlag = (int *)xmalloc(n2d*sizeof(int));
  k = getFluxCoords(n2d,a,theta,Bm,Ract,Zact,Rinitial,Zinitial,Rwant,Zwant,mag_axis_coords,InOutFlag);

  // get the profiles
  REAL *Bpol = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *Ti = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *Te = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *P = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *ne0 = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *qprofile = (REAL *)xmalloc(n2d*sizeof(REAL));
  k = getAllProfiles(n2d,Bpol,Ti,Te,P,ne0,qprofile,a,theta,InOutFlag);

  // get boundary coords
  REAL R_bdy[NBOUNDARY],Z_bdy[NBOUNDARY];
  k = getBoundaryPoints(R_bdy,Z_bdy,NBOUNDARY);

  // cause density, temperature to exponentially decay beyond LCFS
  k = decayNToutsideLCFS(n2d,a,ne0,Te,Ti,InOutFlag);

// no fluctuations
  REAL *ne_tilde = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *phi = (REAL *)xmalloc(n2d*sizeof(REAL));
  int i;
  for(i=0;i<n2d;i++){
    ne_tilde[i] = 0;
    phi[i] = 0;
  }
 
  // write data to a netcdf file
  k = write2dNetcdfFile(NETCDF_FILE_2D,nr,nz,ntimesteps,NBOUNDARY,R1d,Z1d,a,theta,Ract,Zact,Bm,Bpol,Ti,Te,P,ne0,ne_tilde,phi,timesteps,Rinitial,Zinitial,qprofile,R_bdy,Z_bdy,mag_axis_coords);

  k = esifree();			// free memory associated with ESI functions

  free(R1d);			// free memory associated with dynamic arrays
  free(Z1d);
  free(timesteps);
  free(Rwant);
  free(Zwant);
  free(a);
  free(theta);
  free(Bm);
  free(Rinitial);
  free(Zinitial);
  free(Ract);
  free(Zact);
  free(Bpol);
  free(Ti);
  free(Te);
  free(P);
  free(ne0);
  free(qprofile);
  free(ne_tilde);
  free(phi);

  return 0;
}

//! Top-level function to store the 3D profile data in a netCDF file
/*! Uses the specified 1d arrays in the file given by the macro: ``COORD_FILE_3D''
    to generate a 3D grid in (x,y,z) and stores the following
    quantities at those grid points:
    |B|, Bpol, P, ne, Te, Ti, q
*/
int reflectometer_3d_specified_profiles(){
  fprintf(stderr,"started reflectometer_3d_specified_profiles\n");

  // get the position of the magnetic axis
  REAL mag_axis_coords[2];	// (R,Z) of the magnetic axis
  int k = get_mag_axis(mag_axis_coords);

  // get the arrays grid of points we want
  size_t nx,ny,nz,ntimesteps;
  int *timesteps;
  REAL *x1d,*y1d,*z1d;
  k = readSpecified3dCoordFile(COORD_FILE_3D,&nx,&ny,&nz,&ntimesteps,&x1d,&y1d,&z1d,&timesteps);
 
  int n3d = nx*ny*nz; 		// total number of points
  REAL *xwant = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *ywant = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *zwant = (REAL *)xmalloc(n3d*sizeof(REAL));
  k = mesh3dGrid(xwant,ywant,zwant,x1d,y1d,z1d,nx,ny,nz); // the (x,y,z) points we want

  // get the equivalent R,Z,zeta points
  REAL *Rwant = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *Zwant = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *zeta = (REAL *)xmalloc(n3d*sizeof(REAL));
  k = cartesianToCylindrical(n3d,Rwant,Zwant,zeta,xwant,ywant,zwant);

  // get the corresponding flux coords
  REAL *a = (REAL *)xmalloc(n3d*sizeof(REAL)); // flux coords: flux (radial), angle (poloidal), |B|
  REAL *theta = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *Bm = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *Rinitial = (REAL *)xmalloc(n3d*sizeof(REAL)); // the R,Z values of our initial guess
  REAL *Zinitial = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *Ract = (REAL *)xmalloc(n3d*sizeof(REAL)); // actual R,Z coordinates we end up with
  REAL *Zact = (REAL *)xmalloc(n3d*sizeof(REAL));
  int *InOutFlag = (int *)xmalloc(n3d*sizeof(int));
  k = getFluxCoords(n3d,a,theta,Bm,Ract,Zact,Rinitial,Zinitial,Rwant,Zwant,mag_axis_coords,InOutFlag);

  // get the profiles
  REAL *Bpol = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *Ti = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *Te = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *P = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *ne0 = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *qprofile = (REAL *)xmalloc(n3d*sizeof(REAL));
  k = getAllProfiles(n3d,Bpol,Ti,Te,P,ne0,qprofile,a,theta,InOutFlag);

  // get boundary coords
  REAL R_bdy[NBOUNDARY],Z_bdy[NBOUNDARY];
  k = getBoundaryPoints(R_bdy,Z_bdy,NBOUNDARY);

  // cause density, temperature to exponentially decay beyond LCFS
  k = decayNToutsideLCFS(n3d,a,ne0,Te,Ti,InOutFlag);

  // no fluctuation
    REAL *ne_tilde = (REAL *)xmalloc(n3d*sizeof(REAL));
    REAL *phi = (REAL *)xmalloc(n3d*sizeof(REAL));
  int i;
  for(i=0;i<n3d;i++){
    ne_tilde[i] = 0;
    phi[i] = 0;
  }

 
  // write data to a netcdf file
  k = write3dNetcdfFile(NETCDF_FILE_3D,nx,ny,nz,ntimesteps,NBOUNDARY,x1d,y1d,z1d,a,theta,zeta,Rwant,Zwant,Ract,Zact,Bm,Bpol,Ti,Te,P,ne0,ne_tilde,phi,timesteps,Rinitial,Zinitial,qprofile,R_bdy,Z_bdy,mag_axis_coords);

  k = esifree();			// free memory associated with ESI functions

  free(x1d);			// free memory associated with dynamic arrays
  free(y1d);
  free(z1d);
  free(timesteps);
  free(xwant);
  free(ywant);
  free(zwant);
  free(Rwant);
  free(Zwant);
  free(a);
  free(theta);
  free(zeta);
  free(Bm);
  free(Rinitial);
  free(Zinitial);
  free(Ract);
  free(Zact);
  free(Bpol);
  free(Ti);
  free(Te);
  free(P);
  free(ne0);
  free(qprofile);
  free(ne_tilde);
  free(phi);

  return 0;
}


//! Top-level function to store the 2D profile and fluctuations data in a netCDF file
/*! Generates a regular 2D grid in (R,Z) and stores the following
  quantities at those grid points:
  |B|, Bpol, P, ne, ne_tilde, Te, Ti, q
*/
int reflectometer_2d_regular_all(){
  fprintf(stderr,"started reflectometer_2d_regular_all\n");

  // get the position of the magnetic axis
  REAL mag_axis_coords[2];	// (R,Z) of the magnetic axis
  int k = get_mag_axis(mag_axis_coords);

  // set up the grid of points we want: an even grid in (R,Z)
  int nr=NR;			// number of points in 1d array
  int nz = NZ;
  int n2d = nr*nz; 		// total number of points
  REAL R1d[nr], Z1d[nz];
  REAL Rwant[n2d],Zwant[n2d];	// R,Z cylindrical coords and |B|, used by esigetrzb
  k = desiredrz(Rwant,Zwant,R1d,Z1d,nr,nz,mag_axis_coords[0],mag_axis_coords[1]); // the R,Z points we want

  // get the corresponding flux coords
  REAL a[n2d],theta[n2d],Bm[n2d]; // field-line coords: flux (radial), angle (poloidal), |B|
  REAL Rinitial[n2d],Zinitial[n2d]; // the R,Z values of our initial guess
  REAL Ract[n2d],Zact[n2d];	// actual R,Z coordinates we end up with
  int *InOutFlag = (int *)xmalloc(n2d*sizeof(int));
  k = getFluxCoords(n2d,a,theta,Bm,Ract,Zact,Rinitial,Zinitial,Rwant,Zwant,mag_axis_coords,InOutFlag);

  // get the profiles
  REAL Bpol[n2d],Ti[n2d],Te[n2d],P[n2d],ne0[n2d],qprofile[n2d];
  k = getAllProfiles(n2d,Bpol,Ti,Te,P,ne0,qprofile,a,theta,InOutFlag);

  // get boundary coords
  REAL R_bdy[NBOUNDARY],Z_bdy[NBOUNDARY];
  k = getBoundaryPoints(R_bdy,Z_bdy,NBOUNDARY);

  // cause density, temperature to exponentially decay beyond LCFS
  k = decayNToutsideLCFS(n2d,a,ne0,Te,Ti,InOutFlag);
 
  // get the potential fluctuations
  REAL phi[n2d*N_TIME_STEPS],zeta[n2d];
  int i;
  for(i=0;i<n2d;i++) zeta[i] = FLUC_2D_ZETA;
  int timesteps[N_TIME_STEPS];
  for(i=0;i<N_TIME_STEPS;i++){
    timesteps[i]=TIME_START+(TIME_END-TIME_START)/(N_TIME_STEPS-1)*i;
  }
  int* FlucInOutFlag=(int*)xmalloc(n2d*sizeof(int));
  k = get_fluctuations(n2d,N_TIME_STEPS,phi,a,theta,zeta,timesteps,FlucInOutFlag);

  // electrons respond adiabatically to the density
  REAL ne_tilde[n2d*N_TIME_STEPS];
  //  k = total_fluctuations(n2d,N_TIME_STEPS,ne_tilde,ne0,phi,FlucInOutFlag);
    k = adiabaticElectronResponse(n2d,N_TIME_STEPS,ne_tilde,ne0,phi,Te,FlucInOutFlag);

  //write fluctuation files out separately
  for(i=0;i<N_TIME_STEPS;i++){
    char fname[50];
    makeFlucFname(fname,FLUC_FILE_HEAD,timesteps[i]);
    REAL ne_total[n2d];
    int j;
    for(j=0;j<n2d;j++){
      ne_total[j]=ne0[j]+ne_tilde[i*n2d+j];
    }
    
    write2dSnapshot(fname,nr,nz,R1d,Z1d,Ti,Te,Bm,ne_total);
  }
  // write data to a netcdf file
    k = write2dNetcdfFile(NETCDF_FILE_2D,nr,nz,N_TIME_STEPS,NBOUNDARY,R1d,Z1d,a,theta,Ract,Zact,Bm,Bpol,Ti,Te,P,ne0,ne_tilde,phi,timesteps,Rinitial,Zinitial,qprofile,R_bdy,Z_bdy,mag_axis_coords);

  k = esifree();			// free memory associated with ESI functions

  return 0;
}


//! Top-level function to store the 3D profile and fluctuations data in a netCDF file
/*! Generates a regular 3D grid in (x,y,z) and stores the following
  quantities at those grid points:
  |B|, Bpol, P, ne0, ne_tilde, Te, Ti, q
*/
int reflectometer_3d_regular_all(){
  fprintf(stderr,"started reflectometer_3d_regular_all\n");

  // get the position of the magnetic axis
  REAL mag_axis_coords[2];	// (R,Z) of the magnetic axis
  int k = get_mag_axis(mag_axis_coords);

  // set up the grid of points we want: an even grid in (R,Z)
  int nx=Nx;			// number of points in 1d array
  int ny = Ny;
  int nz = Nz;
  int n3d = nx*ny*nz; 		// total number of points
  REAL x1d[nx],y1d[ny],z1d[nz];		// 1d arrays of the (x,y,z) we want
  REAL xwant[n3d],ywant[n3d],zwant[n3d];	// 3d mesh of the (x,y,z) we want
  k = desiredxyz(nx,ny,nz,x1d,y1d,z1d,xwant,ywant,zwant,mag_axis_coords[0],mag_axis_coords[1]); // the R,Z points we want
  // get the equivalent R,Z,zeta points
  REAL Rwant[n3d],Zwant[n3d],zeta[n3d];
  k = cartesianToCylindrical(n3d,Rwant,Zwant,zeta,xwant,ywant,zwant);

  // get the corresponding flux coords
  REAL a[n3d],theta[n3d],Bm[n3d]; // field-line coords: flux (radial), angle (poloidal), |B|
  REAL Rinitial[n3d],Zinitial[n3d]; // the R,Z values of our initial guess
  REAL Ract[n3d],Zact[n3d];	// actual R,Z coordinates we end up with
  int *InOutFlag = (int *)xmalloc(n3d*sizeof(int));
  k = getFluxCoords(n3d,a,theta,Bm,Ract,Zact,Rinitial,Zinitial,Rwant,Zwant,mag_axis_coords,InOutFlag);

  // get the profiles
  REAL Bpol[n3d],Ti[n3d],Te[n3d],P[n3d],ne0[n3d],qprofile[n3d];
  k = getAllProfiles(n3d,Bpol,Ti,Te,P,ne0,qprofile,a,theta,InOutFlag);

  // get boundary coords
  REAL R_bdy[NBOUNDARY],Z_bdy[NBOUNDARY];
  k = getBoundaryPoints(R_bdy,Z_bdy,NBOUNDARY);

  // cause density, temperature to exponentially decay beyond LCFS
  k = decayNToutsideLCFS(n3d,a,ne0,Te,Ti,InOutFlag);

  // get the potential fluctuations
  REAL phi[n3d*N_TIME_STEPS];
  int timesteps[N_TIME_STEPS];
  int i;
  for(i=0;i<N_TIME_STEPS;i++){
    timesteps[i]=TIME_START+(TIME_END-TIME_START)/(N_TIME_STEPS-1)*i;
  }
  int* FlucInOutFlag= (int*) xmalloc(n3d*sizeof(int));
  k = get_fluctuations(n3d,N_TIME_STEPS,phi,a,theta,zeta,timesteps,FlucInOutFlag);

  // electrons respond adiabatically to the density
  REAL ne_tilde[n3d*N_TIME_STEPS];
  k = adiabaticElectronResponse(n3d,N_TIME_STEPS,ne_tilde,ne0,phi,Te,FlucInOutFlag);

  // write data to a netcdf file
  k = write3dNetcdfFile(NETCDF_FILE_3D,nx,ny,nz,N_TIME_STEPS,NBOUNDARY,x1d,y1d,z1d,a,theta,zeta,Rwant,Zwant,Ract,Zact,Bm,Bpol,Ti,Te,P,ne0,ne_tilde,phi,timesteps,Rinitial,Zinitial,qprofile,R_bdy,Z_bdy,mag_axis_coords);

  k = esifree();			// free memory associated with ESI functions

  return 0;
}

//! Top-level function to store the 2D profile and fluctuations data in a netCDF file
/*! Uses the specified 1d arrays in the file given by the macro: ``COORD_FILE_2D''
    to generate a 2D grid in (R,Z) and stores the following
    quantities at those grid points:
    |B|, Bpol, P, ne, ne_tilde, Te, Ti, q
*/
int reflectometer_2d_specified_all(){
  fprintf(stderr,"started reflectometer_2d_specified_all\n");

  // get the position of the magnetic axis
  REAL mag_axis_coords[2];	// (R,Z) of the magnetic axis
  int k = get_mag_axis(mag_axis_coords);

  // set up the grid of points we want: an even grid in (R,Z)
  size_t nr,nz,ntimesteps;
  int *timesteps;
  REAL zeta,*R1d, *Z1d;
  k = readSpecified2dCoordFile(COORD_FILE_2D,&nr,&nz,&ntimesteps,&zeta,&R1d,&Z1d,&timesteps);
 
  int n2d = nr*nz; 		// total number of points
  REAL *Rwant = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *Zwant = (REAL *)xmalloc(n2d*sizeof(REAL));
  k = mesh2dGrid(Rwant,Zwant,R1d,Z1d,nr,nz); // the R,Z points we want

  // get the corresponding flux coords
  REAL *a = (REAL *)xmalloc(n2d*sizeof(REAL)); // flux coords: flux (radial), angle (poloidal), |B|
  REAL *theta = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *Bm = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *Rinitial = (REAL *)xmalloc(n2d*sizeof(REAL)); // the R,Z values of our initial guess
  REAL *Zinitial = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *Ract = (REAL *)xmalloc(n2d*sizeof(REAL)); // actual R,Z coordinates we end up with
  REAL *Zact = (REAL *)xmalloc(n2d*sizeof(REAL));
  int *InOutFlag = (int *)xmalloc(n2d*sizeof(int));
  k = getFluxCoords(n2d,a,theta,Bm,Ract,Zact,Rinitial,Zinitial,Rwant,Zwant,mag_axis_coords,InOutFlag);

  // get the profiles
  REAL *Bpol = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *Ti = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *Te = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *P = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *ne0 = (REAL *)xmalloc(n2d*sizeof(REAL));
  REAL *qprofile = (REAL *)xmalloc(n2d*sizeof(REAL));
  k = getAllProfiles(n2d,Bpol,Ti,Te,P,ne0,qprofile,a,theta,InOutFlag);

  // get boundary coords
  REAL R_bdy[NBOUNDARY],Z_bdy[NBOUNDARY];
  k = getBoundaryPoints(R_bdy,Z_bdy,NBOUNDARY);

  // cause density, temperature to exponentially decay beyond LCFS
  k = decayNToutsideLCFS(n2d,a,ne0,Te,Ti,InOutFlag);

  // get the potential fluctuations
  REAL *phi = (REAL *)xmalloc(n2d*ntimesteps*sizeof(REAL));
  REAL *zeta_arr = (REAL *)xmalloc(n2d*sizeof(REAL));
  int i;
  for(i=0;i<n2d;i++) zeta_arr[i] = zeta;
  int* FlucInOutFlag=(int*)xmalloc(n2d*sizeof(int));
  k = get_fluctuations(n2d,ntimesteps,phi,a,theta,zeta_arr,timesteps,FlucInOutFlag);

  // electrons respond adiabatically to the density
  REAL *ne_tilde = (REAL *)xmalloc(n2d*ntimesteps*sizeof(REAL));
  k = adiabaticElectronResponse(n2d,ntimesteps,ne_tilde,ne0,phi,Te,FlucInOutFlag);
 
  // write data to a netcdf file
  k = write2dNetcdfFile(NETCDF_FILE_2D,nr,nz,ntimesteps,NBOUNDARY,R1d,Z1d,a,theta,Ract,Zact,Bm,Bpol,Ti,Te,P,ne0,ne_tilde,phi,timesteps,Rinitial,Zinitial,qprofile,R_bdy,Z_bdy,mag_axis_coords);

  k = esifree();			// free memory associated with ESI functions

  free(R1d);			// free memory associated with dynamic arrays
  free(Z1d);
  free(timesteps);
  free(Rwant);
  free(Zwant);
  free(a);
  free(theta);
  free(Bm);
  free(Rinitial);
  free(Zinitial);
  free(Ract);
  free(Zact);
  free(Bpol);
  free(Ti);
  free(Te);
  free(P);
  free(ne0);
  free(qprofile);
  free(phi);
  free(zeta_arr);
  free(ne_tilde);

  return 0;
}

//! Top-level function to store the 3D profile and fluctuations data in a netCDF file
/*! Uses the specified 1d arrays in the file given by the macro: ``COORD_FILE_3D''
    to generate a 3D grid in (x,y,z) and stores the following
    quantities at those grid points:
    |B|, Bpol, P, ne, ne_tilde, Te, Ti, q
*/
int reflectometer_3d_specified_all(){
  fprintf(stderr,"started reflectometer_3d_specified_all\n");

  // get the position of the magnetic axis
  REAL mag_axis_coords[2];	// (R,Z) of the magnetic axis
  int k = get_mag_axis(mag_axis_coords);

  // get the arrays grid of points we want
  size_t nx,ny,nz,ntimesteps;
  int *timesteps;
  REAL *x1d,*y1d,*z1d;
  k = readSpecified3dCoordFile(COORD_FILE_3D,&nx,&ny,&nz,&ntimesteps,&x1d,&y1d,&z1d,&timesteps);
 
  int n3d = nx*ny*nz; 		// total number of points
  REAL *xwant = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *ywant = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *zwant = (REAL *)xmalloc(n3d*sizeof(REAL));
  k = mesh3dGrid(xwant,ywant,zwant,x1d,y1d,z1d,nx,ny,nz); // the (x,y,z) points we want

  // get the equivalent R,Z,zeta points
  REAL *Rwant = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *Zwant = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *zeta = (REAL *)xmalloc(n3d*sizeof(REAL));
  k = cartesianToCylindrical(n3d,Rwant,Zwant,zeta,xwant,ywant,zwant);

  // get the corresponding flux coords
  REAL *a = (REAL *)xmalloc(n3d*sizeof(REAL)); // flux coords: flux (radial), angle (poloidal), |B|
  REAL *theta = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *Bm = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *Rinitial = (REAL *)xmalloc(n3d*sizeof(REAL)); // the R,Z values of our initial guess
  REAL *Zinitial = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *Ract = (REAL *)xmalloc(n3d*sizeof(REAL)); // actual R,Z coordinates we end up with
  REAL *Zact = (REAL *)xmalloc(n3d*sizeof(REAL));
  int *InOutFlag = (int *)xmalloc(n3d*sizeof(int));
  k = getFluxCoords(n3d,a,theta,Bm,Ract,Zact,Rinitial,Zinitial,Rwant,Zwant,mag_axis_coords,InOutFlag);

  // get the profiles
  REAL *Bpol = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *Ti = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *Te = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *P = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *ne0 = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *qprofile = (REAL *)xmalloc(n3d*sizeof(REAL));
  k = getAllProfiles(n3d,Bpol,Ti,Te,P,ne0,qprofile,a,theta,InOutFlag);

  // get boundary coords
  REAL R_bdy[NBOUNDARY],Z_bdy[NBOUNDARY];
  k = getBoundaryPoints(R_bdy,Z_bdy,NBOUNDARY);

  // cause density, temperature to exponentially decay beyond LCFS
  k = decayNToutsideLCFS(n3d,a,ne0,Te,Ti,InOutFlag);

  // get the potential fluctuations
  REAL *phi = (REAL *)xmalloc(n3d*ntimesteps*sizeof(REAL));
  int* FlucInOutFlag=(int*)xmalloc(n3d*sizeof(int));
  k = get_fluctuations(n3d,ntimesteps,phi,a,theta,zeta,timesteps,FlucInOutFlag);

  // electrons respond adiabatically to the density
  REAL *ne_tilde = (REAL *)xmalloc(n3d*ntimesteps*sizeof(REAL));
  k = adiabaticElectronResponse(n3d,ntimesteps,ne_tilde,ne0,phi,Te,FlucInOutFlag);
 
  // write data to a netcdf file
  k = write3dNetcdfFile(NETCDF_FILE_3D,nx,ny,nz,ntimesteps,NBOUNDARY,x1d,y1d,z1d,a,theta,zeta,Rwant,Zwant,Ract,Zact,Bm,Bpol,Ti,Te,P,ne0,ne_tilde,phi,timesteps,Rinitial,Zinitial,qprofile,R_bdy,Z_bdy,mag_axis_coords);

  k = esifree();			// free memory associated with ESI functions

  free(x1d);			// free memory associated with dynamic arrays
  free(y1d);
  free(z1d);
  free(timesteps);
  free(xwant);
  free(ywant);
  free(zwant);
  free(Rwant);
  free(Zwant);
  free(a);
  free(theta);
  free(zeta);
  free(Bm);
  free(Rinitial);
  free(Zinitial);
  free(Ract);
  free(Zact);
  free(Bpol);
  free(Ti);
  free(Te);
  free(P);
  free(ne0);
  free(qprofile);
  free(phi);
  free(ne_tilde);

  return 0;
}


//-------------------------------

//! (Deprecated) Top-level function to store the 2D profile data in a netCDF file
/*! Use "refletometer_2d_regular_profiles" instead.
    Generates a regular 2D grid in (R,Z) and stores the following
    quantities at those grid points:
    |B|, Bpol, P, ne, Te, Ti, q
*/
/*
int reflectometer_profiles(){
  fprintf(stderr,"started reflectometer_profiles\n");

  int i,k;
  int nr=NR;			// number of points in 1d array
  int nz = NZ;
  int n2d = nr*nz; 		// total number of points
  REAL a[n2d],theta[n2d]; // field-line coords: flux (radial), angle (poloidal)
  REAL Rwant[n2d],Zwant[n2d],Bm[n2d];	// R,Z cylindrical coords and |B|, used by esigetrzb
  REAL Ract[n2d],Zact[n2d];	// actual R,Z values
  REAL F[n2d],Fa[n2d],gFa[n2d],gFaa[n2d],gYa[n2d],gYaa[n2d]; // used by esilink2c and esiget2dfunctions
  REAL T[n2d],Ta[n2d],P[n2d],Pa[n2d];
  REAL r[n2d],ra[n2d],rq[n2d],z[n2d],za[n2d],zq[n2d];
  REAL B[n2d],Ba[n2d],Bq[n2d],gh[n2d],gha[n2d],ghq[n2d];
  REAL qprofile[n2d], Te[n2d],ne0[n2d],Bpol[n2d];
  REAL R1d[nr], Z1d[nz], R_bdy[NBOUNDARY],Z_bdy[NBOUNDARY];
  REAL mag_axis_coords[2]; //gives R,Z, of mag axis;

  int InOutFlag[n2d];

  // get the position of the magnetic axis
  k = get_mag_axis(mag_axis_coords);

  // get the flux coords for an even grid in R,Z
  k = desiredrz(Rwant,Zwant,R1d,Z1d,nr,nz,mag_axis_coords[0],mag_axis_coords[1]); // the R,Z points we want

  // get the corresponding flux coords
  k = guessatheta(a,theta,Rwant,Zwant,n2d,mag_axis_coords[0],mag_axis_coords[1]); // initial guess for the flux coords
  REAL Rinitial[n2d],Zinitial[n2d]; // the R,Z values of our initial guess
  k = esigetrzb_(Rinitial,Zinitial,Bm,a,theta,&n2d); // map to cylindrical coords
  k = findcorrectatheta(a,theta,Ract,Zact,Bm,Rwant,Zwant,n2d,InOutFlag); // root-find to get flux coords

  // get the profiles
  //k = esigetrzb_(Ract,Zact,Bm,a,theta,&n2d); // map to cylindrical coords
  k = esilink2c_(F,Fa,gFa,gFaa,gYa,gYaa,T,Ta,P,Pa,r,ra,rq,z,za,zq,B,Ba,Bq,gh,gha,ghq);
  k = esiget2dfunctions_(a,theta,&n2d);

  // get q profile
  for(i=0;i<n2d;i++){// reverse of method documented in escZ_march03.c
    if(a[i]==0.0){		// this method is used in setup_v2.F90
      qprofile[i] = -gFaa[i]/gYaa[i]; // the magnetic axis is a special case
    }else qprofile[i]=-gFa[i]/gYa[i];
  }
  
  // get density and temperature profiles
  for(i=0;i<n2d;i++){// need to call Fortran functions
    T[i] = temperature_(&a[i],&theta[i])*NORM_TO_KEV;
    ne0[i] = density_(&a[i],&theta[i])*INVCM3_TO_INVM3;
    Te[i] = temperature_e_(&a[i],&theta[i])*NORM_TO_KEV;	// use this instead for Te, since esiget2dfunctions doesn't give reasonable values 
  }

  // get poloidal magnetic field
  double grad_a;
  for(i=0;i<n2d;i++){
    grad_a = hypot(rq[i],zq[i])/(za[i]*rq[i]-zq[i]*ra[i]);
    Bpol[i] = -grad_a/r[i]*gYa[i];
  }

  k = getBoundaryPoints(R_bdy,Z_bdy,NBOUNDARY);	// get boundary coords

  // cause density, temperature to exponentially decay beyond LCFS
  k = decayNToutsideLCFS(n2d,a,ne0,Te,T,InOutFlag);
 
// no fluctuations
  REAL ne_tilde[n2d],phi[n2d];
  for(i=0;i<n2d;i++){
    ne_tilde[i] = 0;
    phi[i] = 0;
  }

  int timesteps[N_TIME_STEPS] = TIME_STEPS;

  // write data to a netcdf file
  k = write2dNetcdfFile(NETCDF_FILE_2D,nr,nz,N_TIME_STEPS,NBOUNDARY,R1d,Z1d,a,theta,Ract,Zact,Bm,Bpol,T,Te,P,ne0,ne_tilde,phi,timesteps,Rinitial,Zinitial,qprofile,R_bdy,Z_bdy,mag_axis_coords);

  k = reflectometer_fluc_coords(mag_axis_coords);

  k = esifree();			// free memory associated with ESI functions

  return 0;
}
*/

//! Stores the 3D coordinates in flux coordinates for a regular cartesian grid in a netCDF file.
//! Currently called from within reflectometer_profiles()
 
int reflectometer_fluc_coords(REAL mag_axis_coords[]){
  fprintf(stderr,"started reflectometer_fluc_coords\n");
  int status;
  int nx=Nx,ny=Ny,nz=Nz;
  int n3d=nx*ny*nz;

  //  REAL mag_axis_coords[2];	// R,Z position of mag. axis
  // regularly-spaced grid in x,y,z
  REAL *xwant = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *ywant = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *zwant = (REAL *)xmalloc(n3d*sizeof(REAL));

  //status = get_mag_axis(mag_axis_coords); // get posn. of mag. axis

  // form the x,y,z grid
  REAL *x1d = (REAL *)xmalloc(nx*sizeof(REAL));
  REAL *y1d = (REAL *)xmalloc(ny*sizeof(REAL));
  REAL *z1d = (REAL *)xmalloc(nz*sizeof(REAL));
  status = desiredxyz(nx,ny,nz,x1d,y1d,z1d,xwant,ywant,zwant,mag_axis_coords[0],mag_axis_coords[1]);

  // get the equivalent R,Z,zeta points
  REAL *Rwant = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *Zwant = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *zeta = (REAL *)xmalloc(n3d*sizeof(REAL));
  status = cartesianToCylindrical(n3d,Rwant,Zwant,zeta,xwant,ywant,zwant);

  // now map to a,theta,zeta
  REAL *a = (REAL *)xmalloc(n3d*sizeof(REAL));
  REAL *theta = (REAL *)xmalloc(n3d*sizeof(REAL));

  int *InOutFlag = (int *)xmalloc(n3d*sizeof(int));

  status = guessatheta(a,theta,Rwant,Zwant,n3d,mag_axis_coords[0],mag_axis_coords[1]); // initial guess for the flux coords
  REAL Rinitial[n3d],Zinitial[n3d]; // the R,Z values of our initial guess
  REAL Bm[n3d];			// |B|
  status = esigetrzb_(Rinitial,Zinitial,Bm,a,theta,&n3d); // map to cylindrical coords
  REAL Ract[n3d],Zact[n3d];	// actual R,Z
  status = findcorrectatheta(a,theta,Ract,Zact,Bm,Rwant,Zwant,n3d,InOutFlag); // root-find to get flux coords
  //status = esigetrzb_(Ract,Zact,Bm,a,theta,&n3d);

  // get Te at these coords, since Te is necessary to calculate electron adiabatic response
  //  REAL Te[n3d];
  //Te[i] = temperature_e_(&a[i],&theta[i])*NORM_TO_KEV;

  status = writeFlucCoordFile(FLUC_FNAME,nx,ny,nz,xwant,ywant,zwant,Rwant,Zwant,zeta,
			      Ract,Zact,a,theta,Rinitial,Zinitial,mag_axis_coords);
  return 0;
}

// int reflectometer_info_fluc(){
// #if VERBOSE
//   printf("started reflectometer_info_fluc\n");
// #endif

//   int status;

//  int nx=Nx,ny=Ny,nz=Nz;
//int n3d=nx*ny*nz;

// #ifdef BACKUP
//   REAL mag_axis_coords[2];	// R,Z position of mag. axis
//   REAL xwant[n3d],ywant[n3d],zwant[n3d]; // regularly-spaced grid in x,y,z

//   status = get_mag_axis(mag_axis_coords); // get posn. of mag. axis

//   // form the x,y,z grid
//   status = desiredxyz(xwant,ywant,zwant,nx,ny,nz,mag_axis_coords[0],mag_axis_coords[1]);

//   // get the equivalent R,Z,zeta points
//   REAL Rwant[n3d],Zwant[n3d],zeta[n3d];
//   status = cartesianToCylindrical(n3d,Rwant,Zwant,zeta,xwant,ywant,zwant);

//   // now map to a,theta,zeta
//   REAL a[n3d],theta[n3d];
//   status = guessatheta(a,theta,Rwant,Zwant,n3d,mag_axis_coords[0],mag_axis_coords[1]); // initial guess for the flux coords
//   REAL Rinitial[n3d],Zinitial[n3d]; // the R,Z values of our initial guess
//   REAL Bm[n3d];			// |B|
//   status = esigetrzb_(Rinitial,Zinitial,Bm,a,theta,&n3d); // map to cylindrical coords
//   REAL Ract[n3d],Zact[n3d];	// actual R,Z
//   status = findcorrectatheta(a,theta,Ract,Zact,Rwant,Zwant,n3d); // root-find to get flux coords
//   status = writeFlucFile(FLUC_FNAME,nx,ny,nz,xwant,ywant,zwant,Rwant,Zwant,zeta,Ract,Zact,a,theta,
// 			 Rinitial,Zinitial,mag_axis_coords);
// #endif

// int nx,ny,nz;
//   REAL *a,*theta,*zeta;

//   status = readFlucFile(FLUC_FNAME,&nx,&ny,&nz,&a,&theta,&zeta);
//   int n3d=nx*ny*nz;

//   // Thus have the a,theta,zeta coords of the points.
//   // Now we need to interpolate the fluctuation values to those points.
  

  
//   // read in potential data from PHI.000xx files
//   char fname[FNAME_MAX_CHARS];
//   int phi_ints[N_PHI_INTEGERS];
//   REAL phi_reals[N_PHI_REALS];
//   int nsteps,*igrid=NULL,*mtheta=NULL,*itran=NULL;
//   REAL *qtinv=NULL,*deltat=NULL,*vth_grid=NULL,***potential=NULL;
//   int timeSteps[N_TIME_STEPS] = TIME_STEPS;

//   status = readAllPhiFiles(PHI_DATA_DIR,N_TIME_STEPS,timeSteps,phi_ints,phi_reals,&igrid,
// 				    &mtheta,&itran,&qtinv,&deltat,&vth_grid,&potential,&nsteps);
//   // useful: phi_ints,igrid[mpsi],mtheta[mpsi],qtinv[mpsi],potential[ntoroidal][mgrid]
//   //  also gives potential[N_TIME_STEPS,ntoroidal,mgrid]
//   //  N_TIME_STEPS usually = 1, so we're just looking at 1 time step

//   fprintf(stderr,"Number of fluctuation time steps:%d, using time step:%d\n",nsteps,timeSteps[0]);
//   // unpack the integer array
//   int mpsi = phi_ints[2];	// igrid,mtheta,itran,qtinv,deltat,vth_grid have mpsi elements
//   int mgrid = phi_ints[3];	// phi_steps[nsteps][mgrid]
//   int ntoroidal = phi_ints[5];	// number of toroidal points (poloidal slices)

//   // read in psi_grid data
//   REAL *psi_grid = readPsiGridFile(PSI_GRID_FNAME,mpsi);

//   // find the nearest toroidal points (poloidal slices) in the data
//   int toroidalIdxs[n3d][N_NEAREST_TOROIDAL],deltazeta[n3d][N_NEAREST_TOROIDAL];
//   status = nearestPoloidalSlices(n3d,ntoroidal,zeta,toroidalIdxs,deltazeta);

//   // find the value of theta at the lower toroidal pts by following field line
//   //   also returns the nearest two psi grid indices
//   REAL thetaMappedToroidally[n3d][N_NEAREST_PSIGRID];
//   int psi_grid_idxs[n3d][N_NEAREST_PSIGRID]; // nearest psi values with grid points
//   status = traceBtoTorodialPosn(n3d,ntoroidal,mpsi,a,thetaMappedToroidally,
// 				psi_grid_idxs,theta,qtinv,psi_grid,deltazeta);

//   // find the indices of the nearest 2 theta grid points at for each psi grid point
//   //   at the lower toroidal location (the indices are the same at the other location)
//   // also find the distance theta_mapped - theta_grid_lower
//   int theta_grid_idxs[n3d][N_NEAREST_PSIGRID][N_NEAREST_THETAGRID];
//   REAL delta_theta_grid[n3d][N_NEAREST_PSIGRID]; // distance in theta from lower grid pt.
//   status = nearestThetaGridMap(n3d,theta_grid_idxs,delta_theta_grid,
// 			       theta,psi_grid_idxs,igrid,mtheta);

//   // using the values at these (psi_grid,theta_grid,zeta_grid),
//   //   interpolate first toroidally, then poloidally, then between flux surfaces
//   REAL *phi = (REAL *)xmalloc(n3d*sizeof(REAL));
//   status = interpolateTorPolPsi(n3d,phi,a,ntoroidal,mgrid,potential,deltazeta,toroidalIdxs,
// 				theta_grid_idxs,delta_theta_grid,mtheta,psi_grid_idxs,psi_grid);



//   return 0;

// }



#endif
